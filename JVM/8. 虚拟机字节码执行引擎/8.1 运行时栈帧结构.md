
#### 概述

- **介绍**：
	- Java虚拟机*以方法为基本执行单元*，栈帧是支持方法调用与执行的关键数据结构，属于虚拟机栈的元素。栈帧中存储着方法的**局部变量表、操作数栈、动态连接、方法返回地址**等关键信息。
    
- **栈帧组成**：
    
    - **局部变量表**：存放*方法参数和内部定义的局部变量*，包括各种基本数据类型和对象引用。局部变量表的==大小在编译期决定==，与方法代码的复杂性有关。
    - **操作数栈**：后入先出（LIFO）的栈，用于*存放操作指令的输入和输出*。操作数栈的==最大深度也在编译期确定==。
    - **动态连接**：含有*指向运行时常量池的引用，支持方法的动态连接（如方法调用）* 。
    - **方法返回地址**：存储方法执行完毕后的返回位置，方法可以正常完成或通过异常退出。
    - **附加信息**：根据虚拟机实现的不同，栈帧中可能包含额外的信息，如调试信息。

- **方法执行过程**：每个方法从调用开始到执行结束的过程，对应一个栈帧在虚拟机栈中从入栈到出栈的流程。在同一线程中，所有方法在调用栈上似乎都在"同时"执行，但**实际上只有栈顶的栈帧是活动的，称为"当前栈帧"**，关联的方法为"当前方法"。
    
- **执行引擎操作**：虚拟机执行引擎运行的所有字节码指令都是针对当前栈帧进行操作。栈帧的结构和需要的内存分配量由程序源码决定，并不受运行时数据的影响。

- 一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式，*!在编译阶段就已确定! 并且写入到方法表的Code属性之中*。
	- ==在每个方法（method_info结构）中，都有一个属性表（attributes），Code属性就是其中之一。==

![[栈帧的结构.png]]


#### 1. 局部变量表（Local Variables Table）

局部变量表是栈帧的一部分，用于*存储方法参数和内部定义的局部变量* 。这些数据包括各种基本数据类型、对象引用（reference类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置），以及returnAddress类型（指向了一条字节码指令的地址）。

- **变量槽（Variable Slot）**: ==局部变量表的容量以变量槽为单位。==局部变量表中的每个变量槽可以容纳一个32位的数据类型，如`int`、`float`等，或是一个引用类型。`long`和`double`这种64位类型的数据会占用两个变量槽。

- **64位数据类型**：对于long和double这两种64位数据类型，Java虚拟机以高位对齐方式分配两个连续的变量槽空间。*局部变量表是线程私有的，因此读写两个连续变量槽是否为原子操作不会引起线程安全问题*。

- **局部变量表大小**: 在*编译期间确定* ，取决于方法体中局部变量的数量及方法的参数。

- **索引定位**：Java虚拟机通过索引定位方式使用局部变量表，索引值从0开始。对32位数据类型的变量，索引N代表使用第N个变量槽。对64位数据类型的变量，会同时使用N和N+1两个变量槽。

- **方法参数传递**：当一个方法被调用时，局部变量表**用于完成方法参数到参数变量列表的传递**。对实例方法，第0位索引的变量槽默认用于传递方法所属对象实例的引用（this）。其余参数按照参数表顺序排列，占用从1开始的变量槽。
    
- **变量槽复用**：为节省栈帧耗用的内存空间，局部变量表中的变量槽是可重用的。方法体中定义的变量，其作用域不一定覆盖整个方法体。如果字节码PC计数器值超出某个变量的作用域，那个变量对应的变量槽可以被其他变量重用。这种设计节省空间的同时，可能会影响垃圾收集行为。

- **局部变量与类变量初始化**：与类变量不同，*局部变量没有“准备阶段”的赋系统初始值过程*。**局部变量表中的变量若未赋初值，则不能使用**。Java与C/C++在这方面有所不同，Java编译器会在编译期间检查局部变量是否赋初值。



#### 2. 操作数栈（Operand Stack）

操作数栈，也称操作栈，是一种后入先出的栈结构。它是*栈帧的核心组成部分，用于指令执行时的数据输入和输出。*

- **最大深度**：操作数栈的最大深度在编译时确定，并记录在方法的Code属性的max_stacks数据项中。操作数栈的元素可以是任意Java数据类型，包括`long`和`double`。
    
- **栈容量**：32位数据类型占用的栈容量为1，而64位数据类型占用的栈容量为2。Javac编译器的数据流分析工作保证了在方法执行的任何时候，操作数栈的深度都不会超过max_stacks中定义的最大值。
    
- **运行时行为**：当*方法开始执行时，操作数栈是空的*。*方法执行过程中，字节码指令会向操作数栈写入和提取数据，进行出栈和入栈操作*。例如，整数加法指令（`iadd`）要求操作数栈顶的两个元素是两个`int`型数值，执行时将这两个数值出栈，相加，然后将结果入栈。
    
- **数据类型匹配**：操作数栈中元素的数据类型必须与字节码指令序列严格匹配。编译器在编译程序代码时会确保这一点，类校验阶段的数据流分析中会再次验证。
    
- **栈帧间的优化**：虽然概念模型中不同栈帧是完全独立的，但在多数虚拟机实现中会对栈帧进行优化，使得相邻的栈帧在操作数栈和局部变量表部分发生重叠，以节约空间并简化方法调用过程。


![[栈帧数据共享.png]]

#### 3. 动态连接

每个栈帧内部*包含一个或多个指向运行时常量池(元空间/方法区)中该方法的符号引用*，Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令*就以常量池里指向方法的符号引用作为参数。*

- 这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。 
- **另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接**。这个机制保证了Java虚拟机能在运行时动态绑定方法和变量。



#### 4. 方法返回地址

栈帧中存储着方法完成后的返回地址。方法可以通过正常完成退出或异常退出（如遇到未捕获的异常）。
- 正常退出时，栈帧将使用方法返回地址来确定下一步执行的位置
- 异常退出时，将通过*异常表*来确定跳转的位置，不需要保存返回地址。

⽆论采⽤何种退出⽅式，==在⽅法退出之后，都必须返回到最初⽅法被调⽤时的位置==，程序
才能继续执⾏，⽅法返回时可能需要在栈帧中保存⼀些信息，⽤来帮助恢复它的上层主调
⽅法的执⾏状态。 ⼀般来说，
- ⽅法正常退出时，**主调⽅法的PC计数器的值就可以作为返回地址**，栈帧中很可能会保存这个计数器值。
- ⽽⽅法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中就⼀般不会保存这部分信息。

*⽅法退出的过程实际上等同于把当前栈帧出栈*，因此退出时可能执⾏的操作有:
- 恢复上层⽅法的局部变量表和操作数栈
- 把返回值(如果有的话)压⼊调⽤者栈帧的操作数栈中
- 调整PC计数器的值以指向⽅法调⽤指令后⾯的⼀条指令等。

#### 5. 附加信息

Java虚拟机规范允许在栈帧中包含额外信息，比如与调试、性能收集相关的信息。这部分内容完全取决于虚拟机的具体实现，为虚拟机执行提供了更多的灵活性和扩展性。