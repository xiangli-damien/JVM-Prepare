
*方法调用阶段唯一的任务就是确定被调用方法的版本 (即调用哪一个方法)，暂时还未涉及方法内部的具体运行过程。* 在程序运行时，进行方法调用是最 普遍、最频繁的操作之一。

第7章中已经讲过，Class文件的编译过程中不包含传统程序语言编译的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局 中的入口地址(也就是之前说的直接引用)。

这个特性给Java带来了更强大的动态扩展能力，但也使 得Java方法调用过程变得相对复杂，**某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用**。

#### 解析

- ==所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用==
- 解析阶段会把一部分符号引用转化为直接引用。前提是方法在程序真正运行之前就有一个可确定的调用版本，且这个版本在运行期不会改变。
- 静态方法和私有方法由于不可能通过继承或别的方式被重写，因此适合在类加载阶段进行解析。
- Java虚拟机支持的方法调用字节码指令包括`invokestatic`、`invokespecial`、`invokevirtual`、`invokeinterface`和`invokedynamic`。
- 方法调用的解析和类加载的解析的区别：
	- 类加载中的解析是静态过程，主要解决的是类与类之间的关系和符号引用的直接引用问题
	- 而方法调用中的解析是动态过程，主要解决的是在程序运行时，如何根据对象的实际类型找到正确的方法版本。

#### 分派

- **静态分派** 发生在编译期，依赖静态类型来决定方法执行版本，典型表现为*方法重载*。它是通过参数的静态类型而不是实际类型作为判定依据。
- **动态分派** 发生在运行期，依赖于接收者的实际类型来选择方法版本，与方法重写有密切关联。Java语言中方法重写的本质。
- **单分派和多分派** Java语言是静态多分派、动态单分派的语言。静态分派涉及到方法的接收者和方法参数两个宗量，而动态分派只关心接收者的实际类型。

#### 其他

- Java虚拟机中的动态分派采用虚方法表(vtable)来优化方法调用。当子类没有重写父类方法时，子类的虚方法表中的地址入口和父类相同方法的地址入口一致，指向父类实现入口。
- 字段不参与多态，即字段无论在哪个类中定义，都不会进行动态类型判定。与方法不同，字段的访问只与声明该字段的类相关，不受字段所在对象实际类型的影响。