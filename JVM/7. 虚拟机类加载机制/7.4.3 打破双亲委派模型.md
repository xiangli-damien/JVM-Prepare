

双亲委派模型虽然是Java设计推荐的类加载器实现方式，但在实际应用中存在几种破坏这一模型的情况。

#### 破坏情况一：JDK 1.2之前

- 在JDK 1.2引入双亲委派模型之前，类加载器的概念已存在，双亲委派模型的引入需要兼容旧有代码，导致`loadClass()`方法不能阻止被子类覆盖。
- 解决方案是引入`findClass()`方法，让用户重写这个方法而不是`loadClass()`，以此兼容双亲委派模型。

#### 破坏情况二：JNDI服务

- JNDI服务需要调用用户代码，但其类由启动类加载器加载，无法直接访问用户类路径下的类。
- 通过线程上下文类加载器（Thread Context ClassLoader）作为桥梁，实现了基础类与用户代码之间的调用，这种做法实际上破坏了双亲委派模型的原则。

#### 破坏情况三：OSGi的动态模块化系统

- OSGi通过每个程序模块有自己的类加载器实现模块的动态热替换。
- 类加载器之间的关系由树状结构变为网状结构，破坏了双亲委派模型，实现了更加复杂的模块间依赖和类加载机制。

#### 总结

- “破坏”并不总是负面的，对双亲委派模型的破坏在特定场景下是创新的尝试。
- 破坏双亲委派模型允许了更灵活的类加载策略，尤其是在需要动态加载、替换或升级模块时。
- OSGi的实现虽然复杂，但提供了值得学习的类加载器使用精粹。

