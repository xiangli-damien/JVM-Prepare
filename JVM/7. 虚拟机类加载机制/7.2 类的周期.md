
### 类加载的时机

Java 类从被加载到虚拟机内存中开始，到卸载出内存为止，其生命周期会经历以下七个阶段：

1. 加载（Loading）
2. 验证（Verification）
3. 准备（Preparation）
4. 解析（Resolution）
5. 初始化（Initialization）
6. 使用（Using）
7. 卸载（Unloading）

其中，*验证、准备、解析三个部分统称为连接（Linking）*。

![[类的生命周期.png]]

### 类的生命周期

- ==加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的==，必须严格按此顺序开始。
- 解析阶段可能会在初始化之后开始，以支持**Java 的动态绑定特性**。
- 这些进程都是按照这个顺序*开始*，但不一定是按这个顺序结束。==这些阶段通常是交叉进行的==，一个阶段可能会在执行中调用或激活另一个阶段。

### 类的主动引用

按照《Java虚拟机规范》，有且只有以下*六种情况*必须立即对类进行初始化：

1. 遇到 `new`、`getstatic`、`putstatic` 或 `invokestatic` 四条字节码指令时，如果类没有初始化，则需先触发初始化。典型场景：
	- 使用 `new` 实例化对象时。
	- 读取或设置类的静态字段时（除了编译期静态字段）。
	- 调用类的静态方法时。

2. 当使用 `java.lang.reflect` 包的方法对类进行反射调用时，如果类未初始化，则先触发初始化。

3. 当初始化类时，如果发现其父类未初始化，则先触发其父类的初始化。

4. 虚拟机启动时，用户指定的执行主类（包含 `main()` 方法的类），虚拟机会初始化这个主类。

5. 使用 JDK 7 的动态语言支持时，若 `MethodHandle` 实例最后的解析结果为 `REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`、`REF_newInvokeSpecial`，且对应类未初始化，则先触发初始化。

6. 当接口中定义了 JDK 8 新增的默认方法时，若有该接口的实现类发生了初始化，则该接口会在其之前被初始化。

以上六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。
