
元空间是从JDK 8开始引入的内存区域，用于替代原来的永久代（PermGen），存储类的元数据。

- **为什么引入元空间**
	- **内存管理的灵活性**：与永久代不同，元空间使用的是==本地内存（Native Memory）==，不再受Java堆的最大内存限制约束，提高了内存使用的灵活性。
	- **避免内存溢出**：永久代容易因为固定的内存大小而发生内存溢出错误（`OutOfMemoryError`）。元空间的引入降低了这种风险，因为它可以动态扩展内存使用。

- **元空间的工作原理**
	- **类元数据存储**：元空间主要存储类的元数据信息，如==运行时常量池==、字段和方法数据，以及方法和构造函数的字节码。
	- **内存分配**：虽然元空间使用的是本地内存，但JVM还是提供了参数来限制其使用量，如`-XX:MetaspaceSize`和`-XX:MaxMetaspaceSize`。

- **元空间与永久代的差异**
	- **内存区域**：永久代位于Java堆内，而元空间利用本地内存。
	- **垃圾收集**：元空间的垃圾收集更为高效，因为它不需要像永久代那样频繁地执行完整的垃圾收集。

- **异常情况**
	- 如果元空间无法申请到足够的本地内存，Java虚拟机将抛出`OutOfMemoryError`异常。

- **配置元空间大小**
	- 使用`-XX:MetaspaceSize`参数设置初始空间大小，
	- `-XX:MaxMetaspaceSize`设置最大空间大小。
	- 不设置`-XX:MaxMetaspaceSize`将允许元空间动态扩展至本地内存上限。


- ### **常量池**

	- **运行时常量池**：
		- 运行时常量池是每个类或接口的常量池的运行时表示形式。
		- 它包含了若干种不同的常量，从编译期间生成的字面量到方法和字段的引用。
		- 这部分内容是类文件中常量池表的运行时表示，包括直接量（如文本字符串、声明为`final`的常量值等）和对其他类型、方法、字段的符号引用。
	- **字符串常量池**：	
		- 字符串常量池（String Pool）是用于存储字符串对象的特殊内存区域。
		- Java中的每个唯一的字符串常量都会被存储在字符串常量池中，以减少内存开销。如果创建的字符串已经存在于池中，则不会创建新对象，而是返回池中的对象引用。

	- **JDK 8之前和之后的位置变化**：
	- 之前
		- ==运行时常量池是方法区的一部分==，而方法区（PermGen，永久代）是堆的逻辑部分。
		- ==字符串常量池也位于方法区中==，即PermGen中。
	- 之后
		- 方法区的概念（PermGen）被元空间（Metaspace）取代，元空间不在虚拟机内存中，而是使用本地内存。
		- 运行时常量池==现在在元空间（Metaspace）==
		- ==字符串常量池被移动到Java堆内存中==。这意味着JDK 8及之后版本中，字符串常量池利用堆内存，而类的元数据（包括运行时常量池）存储在元空间中。