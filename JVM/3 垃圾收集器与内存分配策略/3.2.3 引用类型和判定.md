
### 定义转变

- JDK 1.2之前：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用。
	- 缺点：无法描述某些对象:
		- 当内存空间还足够时，能保留在内存之中，
		- 如果内存空间在GC后仍然非常紧张，那就可以抛弃这些对象。

- JDK 1.2之后： 引入了四种不同强度的引用类型，以适应更加灵活的内存管理需求。

### 引用类型

1. **强引用（Strong Reference）**
    
    - 定义: 最传统的引用形式，如`Object obj = new Object();`这样的引用关系。
    - 特点: 只要强引用还存在，JVM宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

1. **软引用（Soft Reference）**
    
    - 定义: 通过`SoftReference`类实现，用于描述一些有用但非必需的对象。
    - 特点: 在系统即将发生内存溢出之前，只有软引用的对象会被回收，以尝试释放内存。

1. **弱引用（Weak Reference）**
    
    - 定义: 通过`WeakReference`类实现，比软引用更弱，用于描述非必需对象。
    - 特点: 对象只能生存到下一次垃圾收集发生之前，无论内存是否足够，都会被回收。
    - 与软引用的区别： 只具有弱引用的对象具有*更短的生命周期* ，GC一旦发现若弱引用对象，不管内存充不充足，都会直接回收。
    - 可以配合引用队列（ReferenceQueue）联合使用， optional

1. **虚引用（Phantom Reference）**
    
    - 定义: 通过`PhantomReference`类实现，是所有引用类型中最弱的一种。
    - 特点: 对象的存在与否不会受虚引用影响，设置虚引用的唯一目的是在对象被收集器回收时收到一个系统通知。

    - 虚引用与软引用和弱引用的一个区别在于：
	    - 虚引用*必须和引用队列（ReferenceQueue）联合使用*。
		    1. 当准备GC一个对象时，如果发现它还有虚引用，就会先把这个虚引用加入到与之关联的引用队列中。
		    2. 程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。


### 对象回收两次标记过程

在GC过程中，即使对象在可达性分析中被判定为不可达，它也不会立即死亡。对象在被垃圾收集器回收之前，至少会经历==**两次标记过程**==：

1. **第一次标记**: 发生在对象没有与GC Roots相连的引用链时。

2. **执行`finalize()`方法**: 如果对象覆写了`finalize()`方法，且未被虚拟机调用过，将执行此方法，给对象一个自救的机会。
	- 对象会被放入一个F-queue队列之中
	- 稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize() 方法，*并不承诺结束之后再进行第二次GC* 。

3. **第二次标记**: 如果`finalize()`中成功建立了与GC Roots的连接，则对象在第二次标记时会被移除出待回收集合。反之将被回收。

- ==**注意**==：任何一个对象的*finalize()方法都只会被系统自动调用一次*

### 回收方法区

方法区（或HotSpot虚拟机的元空间）中的垃圾收集主要涉及两部分内容：

1. **废弃常量**: 与Java堆中的对象回收类似，如果某个常量不再被任何引用，那么它可以被回收。
2. **废弃类**: 要判断一个类型是否不再被使用，需要满足：

	- 该*类所有的实例* 都已经被回收，也就是 Java 堆中不存在该类的任何实例。
	- 加载该*类的 `ClassLoader`* 已经被回收。
	- 该类对应的 *`java.lang.Class` 对象没有在任何地方被引用* ，无法在任何地方通过反射访问该类的方法



尽管方法区的垃圾收集的性价比通常较低，但在使用大量反射、动态代理、字节码框架等技术的场景中，对类型进行回收是避免方法区内存压力的关键措施。