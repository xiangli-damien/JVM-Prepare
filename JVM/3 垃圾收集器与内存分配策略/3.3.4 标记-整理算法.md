


标记-整理算法是为了克服标记-复制算法在*对象存活率较高时的效率问题* 和*避免浪费50%空间的缺陷* 而提出的。它在处理**老年代对象**的存活特性时显示出优越性。

### 核心过程

- **标记阶段**：与标记-清除算法相同，标记出所有存活的对象。
- **整理阶段**：将所有存活的对象向一端移动，然后直接清理掉边界以外的内存。

![[标记-整理算法.png]]

### 优缺点分析

- **优点**：
	- 解决了内存碎片化的问题，*提高了内存的利用率* 。
	- 避免浪费部分内存

- **缺点**：
	- 移动对象需要更新所有引用这些对象的地方，这可能是成本较高的操作，特别是在老年代这种对象存活率高的区域。
	- 此外，整理过程通常需要暂停用户应用程序（Stop The World）。

### 应用场景

- 适用于老年代垃圾收集。老年代因为对象存活率高，使用*标记-复制算法不够高效* ，同时*不想因标记-清除算法引入的碎片化问题而影响性能* 。（这里的性能指的是总的吞吐量，实际上标记-清除算法会*降低延迟* ）

### 停顿时间 VS 吞吐量

- **停顿时间**：标记-整理算法和标记-清除算法都需要停顿用户线程，但标记-整理算法因移动对象而可能导致更长的停顿。
- **吞吐量**：标记-整理算法由于解决了内存碎片化，有助于提高系统*总体的吞吐量*，尤其是内存分配和访问频率较高的场景。
	- 吞吐量的实质是赋值器(Mutator，可以理解为使用垃圾收集的用户程序)与收集器的效率总和。
	- 标记清除法尽管停顿时间较短，收集器效率高于标记整理，但是*内存分配和访问时间大大增加，总体效率低，吞吐量低*
##### 实际应用

- **HotSpot虚拟机**：
	- 关注吞吐量的`Parallel Scavenge`收集器采用标记-整理算法；
	- 而关注延迟的`CMS`收集器则基于标记-清除算法，但面对空间碎片化问题时会切换到标记-整理算法进行处理。

### "和稀泥"式解决方案

- 在多数情况下采用标记-清除算法，直到内存碎片化严重影响性能时，再通过标记-整理算法进行垃圾收集，以获得连续的内存空间。例如**CMS**

### 技术演进

- 最新的垃圾收集器如`ZGC`和`Shenandoah`采用技术创新（如读屏障）允许标记-整理过程与用户线程并发执行，大幅减少停顿时间，进一步提高了收集效率和应用程序的响应能力。