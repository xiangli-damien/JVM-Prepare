
### G1垃圾收集器概述

- **简介**：G1收集器是一种*面向服务端应用* 的垃圾收集器，采用基于*Region的堆内存布局和局部收集策略* 。
- **目标**：旨在替换CMS收集器，提供*可预测的停顿时间模型* ，即允许用户指定在一个时间片段内，垃圾收集消耗时间的上限。

### 核心特性

- **基于Region的堆布局**：不再使用分代区域划分（仍然保有分代理念），将整个Java堆划分为多个==大小相等的独立区域（Region）==。
	- 每个Region被视为*单次最小回收单元*。
	- 每个Region根据需要扮演新生代的Eden区、Survivor区或者是老年代区域。
	- Region中还有一类特殊的*Humongous区域*，专门用来存储大对象（超过Region容量一半）。
	
- **混合垃圾收集（Mixed GC）模式**：G1可以根据每个Region内的垃圾堆积情况以及回收价值和成本，动态决定哪些Region应该被回收，从而实现在有限的时间内获得最高的回收效率。
	- 跟踪每个Region里面的内存价值大小，优先处理回收价值收益最大的那些Region。
	- 价值即*回收所获得的空间大小以及回收所需时间*的比值
	- 然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region
![[G1收集器堆分区.png]]
###   G1垃圾收集器实现细节挑战


1. **跨Region引用处理**：
    - **问题**：Java堆被划分为多个独立的Region后，存在跨Region引用的对象，这如何解决？
    - **解决方案**：采用*记忆集（Memory Set）来避免全堆扫描*。G1为*每个Region维护一个记忆集* ，记录其他Region指向自己的指针。这个记忆集是一种复杂的哈希表结构，每个键值对记录了引用源的Region起始地址和目标Region中具体的卡表索引。这种*双向的卡表结构*，虽然比传统的卡表更复杂，但提供了更高效的引用追踪方式。
     
2. **并发标记与用户线程的交互**：
    - **问题**：如何在并发标记阶段保证收集线程与用户线程互不干扰，防止改变对象引用关系导致标记结果出错？
    - **解决方案**：G1采用了==**原始快照（SATB）算法**==来跟踪引用变化。此外，G1为每一个新对象设计了两个*TAMS（Top at Mark Start）指针*，*为并发回收过程中新创建的对象分配空间*，保证这些对象默认被认为是存活的，从而防止并发时的指针变化影响收集准确性。
    
3. **停顿时间预测模型的构建**：
    
    - **问题**：如何实现可靠的停顿时间预测模型，满足用户设定的期望值？
    - **解决方案**：G1基于*衰减均值理论构建预测模型*，通过记录和分析每个Region的回收成本、记忆集中的脏卡数量等数据，建立统计信息。利用这些数据预测回收价值，形成优先级列表，从而在不超过用户设定停顿时间的前提下，选择收益最高的Region进行回收。


### 垃圾收集过程

- **初始标记（Initial Marking）**：标记从GC Roots直接可达的对象，同时修改TAMS（Top at Mark Start）指针，此阶段会引起*短暂的停顿* 。
- **并发标记（Concurrent Marking）**：从GC Roots开始递归扫描整个堆，标记可达对象。这个阶段与用户线程并发执行，*不会造成用户线程停顿*，结束后还要重新处理（原是快照）SATB记录下的在并发时有引用变动的对象。
- **最终标记（Final Marking）**：处理并发标记阶段遗留的一些工作，主要是处理SATB（Snapshot At The Beginning）队列中的剩余对象。这个阶段需要*短暂停顿*。
- **筛选回收（Evacuation）**：根据前面的标记结果，评估各个Region的回收价值和成本，选择一部分Region进行实际的回收。这一步需要*停顿用户线程，但可以通过设定的停顿时间来控制*。

![[G1收集器.png]]
### 优缺点分析

- **优点**：
    - **可控制的停顿时间**：G1允许用户设定停顿时间目标，以满足不同场景下对响应时间的敏感需求。
    - **高效的垃圾回收**：通过优先回收价值最大的Region，G1能够在有限的时间内收集大量垃圾，提高回收效率。
    - **减少内存碎片**：采用*标记-整理以及标记-复制* 算法，保证了收集完成后的堆内存是连续的，避免了内存碎片问题。
- **缺点**：
    - **较高的内存占用**：为了维护每个Region的记忆集和其他结构，G1可能需要占用较多的堆外内存。
    - **运行时开销**：G1的并发标记和维护记忆集等操作可能会增加运行时的CPU负载
	    - CMS用*写后屏障来更新维护卡表*
	    - G1除了使用*写后屏障* 来进行卡表维护操作外，为了实现原始快照搜索  (SATB)算法，还需要使用*写前屏障* 来跟踪并发时的指针变化情况。


### 应用场景和未来展望

- **适用场景**：==适合内存较大，对停顿时间敏感的服务端应用==。特别是当应用需要更好地控制GC停顿时间，或者需要在大堆内存中运行时，G1提供了更加灵活和高效的垃圾收集策略。
- **未来展望**：G1已成为JDK 9及以后版本中的默认垃圾收集器，逐步取代了CMS收集器。