
标记-复制算法，也称为复制算法，是*为了优化标记-清除算法在处理大量可回收对象时的低效率问题* 而提出的。
这种算法通过将内存划分为*两块等大的区域* ，每次仅使用其中一块，来实现高效的垃圾回收。

### 核心思想

- 将可用内存划分为**两个大小相等的区域**。
- 每次只使用一块区域，当这块区域的内存用尽时，==将存活的对象复制到另一块区域，然后清理已使用的内存区域。

![[标记复制算法.png]]

### 优点

- *高效处理大量可回收对象*的情况，只需复制少数存活对象。
- 简化内存分配策略，*避免了内存碎片问题*，分配内存时仅需移动堆顶指针。

### 缺点

- 可用内存缩减为原来的一半，存在一定程度的==空间浪费==。

### 应用

- 主要用于*新生代的垃圾回收* 。IBM的研究表明，新生代中的对象有98%熬不过第一轮收集，使得标记-复制算法特别适合新生代。

### Appel式回收

- 基于半区复制理论，Appel式回收进一步优化了新生代的内存布局，将*新生代分为一块较大的Eden空间和两块较小的Survivor空间* 。
- 垃圾收集时，从Eden和一块Survivor复制存活对象到另一块Survivor空间，清理Eden和之前的Survivor空间。
- HotSpot虚拟机的*Serial、ParNew等新生代收集器* 均采用了这种策略来设计新生代的内存布局，设置Eden和Survivor的比例为8:1，使得90%的新生代空间被利用。
#### (特殊情况)内存分配担保

- 面对Survivor空间不足以容纳所有存活对象的罕见情况，Java虚拟机采用分配担保机制，将==存活对象直接晋升到老年代==，保证系统的稳定性和安全性。

标记-复制算法通过有效管理存活对象的复制过程，解决了标记-清除算法的主要缺陷，尤其在新生代垃圾回收中展现出高效和实用的特点。然而，它牺牲了一半的内存空间作为交换，是空间效率和回收效率之间的一种折中选择。

