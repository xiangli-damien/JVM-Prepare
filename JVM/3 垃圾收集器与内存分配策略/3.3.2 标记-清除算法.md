

标记-清除算法是垃圾收集领域最早和最基本的算法之一（1960年）。其过程分为两个主要阶段：标记和清除。

### 算法过程

1. **标记阶段**：遍历所有对象，标记出所有需要回收的对象，或者相反地，标记所有存活的对象。
2. **清除阶段**：统一回收所有被标记的对象，或者回收所有未被标记的对象。

### 主要缺点

1. **执行效率不稳定**：如果Java堆中*对象数量庞大且大部分对象都需要被回收* ，会导致标记和清除两个过程的执行效率*随对象数量增加而显著降低* 。
2. **内存碎片化**：标记和清除过程完成后，会*留下许多不连续的内存碎片*。过多的内存碎片可能*导致在后续需要分配较大对象时无法找到足够连续的内存空间* ，进而不得不提前触发新的垃圾收集。

![[标记清除算法.png]]


### 改进方向

由于标记-清除算法的这些缺点，后续的垃圾收集算法多在其基础上进行改进，目的是提高垃圾收集的效率并减少内存碎片化问题。例如：

- 标记-整理（Mark-Compact）算法就是一种改进，
	- 它不仅回收垃圾，还会整理剩余对象，使它们在内存中连续排列，解决碎片化
	- 缺点：移动存活对象消耗大量资源，并且需要暂停程序更长时间
	- 适用于：老生代
-  标记-复制算法 
	- 针对大量可回收对象以及内存碎片化
	- 缺点： 浪费部分空间用于复制
	- 适用于：新生代


