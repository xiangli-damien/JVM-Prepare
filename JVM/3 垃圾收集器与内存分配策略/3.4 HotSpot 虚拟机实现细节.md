
### 根节点枚举

- **目标**：从GC Roots开始，找到所有引用链。
- **挑战**：大型Java应用中，全局引用和执行上下文极其庞大，逐个检查代价高昂。
- **解决方案**：使用**OopMap数据结构**快速定位对象引用。

	- 一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译(第11章)过程中，也 会在特定的位置记录下栈里和寄存器里哪些位置是引用。

- **用户线程停顿**：必须在"Stop The World"状态下进行，以保持引用关系的一致性。

### 安全点 (Safepoint)

- **定义**：
	- 程序执行中能安全暂停进行GC的点。
	- HotSpot也的确没有为每条指令都生成OopMap，只是在==安全点==记录了这些信息

- **选取标准**：
	- 太多：频繁GC
	- 太少：收集器等待时间过长
	- 设置在*具有长时间执行特征的代码位置*，如方法调用、循环跳转。

- **实现方式**：
	- **抢先式中断 (Preemptive Suspension)**：虚拟机会中断所有线程，如果线程不在安全点，它会被恢复执行直到它到达一个安全点。*不建议*
	- **主动式中断 (Voluntary Suspension)**：不直接中断线程，而是设置一个标志，线程会定期检查（轮询）这个标志，并在检测到标志为真时在最近的安全点上自行挂起。


### 安全区域 (Safe Region)

- **目的**：解决线程处于无法立即响应GC的状态，如Sleep或Blocked。
- **工作原理**：在代码片段内，引用关系不变化的区域，任何时刻开始GC都是安全的。
- **线程处理**：
	- 线程进入安全区域时标记自身，
	- 直到离开安全区域并==检查==是否可以继续执行：
		- 检查虚拟机是否已经完成了根节点枚举(或者垃圾收集过程中其他需要暂停用户线程的阶段)。

### 记忆集与卡表

- **目的**：
	- 记录从**非收集区域指向收集区域的指针**(Remeber Set)，减少GC Roots扫描范围。

- **实现方法**：
    - **记忆集**：抽象数据结构，记录跨代引用。
    - **卡表**：具体实现，每个元素代表一块内存区域（卡页）。
	    - 只要卡页内有一个(或更多)对象的字段存在着跨代指针
	    - 那就将对应卡表的数组元素的值标识为1，称为这个元素变脏(Dirty)，没有则标识为0。
	    - 在GC时，只要筛选出卡表中变脏的元素，得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。

![[卡表和卡页对应.png]]

- **记录精度**：
    - 字长精度：记录精确到机器字长。
    - 对象精度：记录精确到包含跨代指针的对象。
    - **卡精度**：记录精确到含有跨代指针的内存区域，是最常用实现。(*通过卡表实现* )


### 写屏障

- **概述** 
	- 写屏障是HotSpot虚拟机中用于*维护卡表状态* 的关键技术
	- 用于解决如何*在对象引用更新时自动维护卡表元素* 的问题。

- **何时变脏**
	- **条件**：当对象引用跨代指向时（例如，老年代对象引用新生代对象），对应的卡表元素需要标记为脏（dirty）。
	- **时机**：在引用类型字段赋值的那一刻。


- *写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面*，分为：

	- **写前屏障 (Pre-Write Barrier)**：赋值操作之前执行的动作。
	- **写后屏障 (Post-Write Barrier)**：赋值操作之后执行的动作，主要用于更新卡表状态。


- **性能考量**
	- **开销**：写屏障引入的额外开销相对于扫描整个老年代的成本更低。
	- **伪共享 (False Sharing)问题**：多线程环境下，更新操作可能影响性能。为避免这一问题，可通过条件性更新卡表来减少不必要的写操作。
	- **JDK 7+ 优化**：通过`-XX:+UseCondCardMark`参数控制是否启用条件卡表更新，以平衡伪共享问题与性能损耗。


> 区分**写屏障**、**读屏障**与并发编程中的**内存屏障**。
> 
> 写屏障是面向切面编程(AOP)在虚拟机层面的一种应用，实现了引用赋值操作的环绕通知。




### 并发可达性分析

^dfffab

- **挑战**：
	- 可达性分析通常需要在所有用户线程停止下来的一致性快照上进行，这导致了与Java堆容量正比的停顿时间。
- **目的**：
	- 减少或解决用户线程的停顿时间： 
		- 如何在用户线程和垃圾收集器线程并发运行时，保持对象图的一致性？
    
- **三色标记法**：以白色、灰色、黑色区分对象的访问状态，辅助理解并发标记过程中的对象状态变化。
    
    - **白色**：尚未被垃圾收集器访问过的对象。
    - **黑色**：已经被垃圾收集器访问过，且所有引用都已检查过的对象。
    - **灰色**：被垃圾收集器访问过，但至少有一个引用未被检查的对象。
	
	- **弊端：对象消失问题**：并发执行中，用户线程的修改操作可能导致存活对象被错误标记为死亡（对象消失）。
    
- **解决方案**：
    
    - **增量更新（Incremental Update）**：记录黑色对象到白色对象的新引用，赋值后重新扫描这些引用。*有变化的新引用重新扫描一遍*

    - **原始快照（Snapshot At The Beginning, SATB）**：记录灰色对象删除的白色对象引用，*无论引用关系如何变化，都按照初始快照进行搜索*。

![[并发可达性分析.png]]
- **HotSpot虚拟机应用**：
    
    - **CMS收集器**使用增量更新策略。
    - **G1和Shenandoah收集器**采用原始快照策略。

- **写屏障**：HotSpot虚拟机通过写屏障技术在引用更新时维护卡表状态，同时处理增量更新和原始快照的记录需求。