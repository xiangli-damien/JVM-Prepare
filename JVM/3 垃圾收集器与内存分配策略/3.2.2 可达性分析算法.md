
可达性分析算法是主流商用程序语言（如Java、C#，及早期的Lisp）内存管理的核心，用于判断对象是否存活。相比于引用计数算法解决了**循环引用**的问题

#### 基本思路

- **起始节点**: 从称为=="GC Roots"==的一系列根对象开始。
- **搜索路径**: 沿==引用链（Reference Chain）==向下搜索。
- **判定标准**: 若从GC Roots到某对象无引用链相连（图论中的不可达），则对象不再被使用，可回收。
![[可达性分析.png]]

#### 哪些对象可以作为GC Roots：

1. **虚拟机栈引用对象**: 如方法堆栈中的参数、局部变量等。
2. **方法区中静态属性引用对象**: 如类静态变量。
3. **方法区中常量引用对象**: 如字符串常量池内的引用。
4. **本地方法栈中JNI引用(即Native 方法)的对象**.
5. **Java虚拟机内部引用**: 如基本数据类型的Class对象，常驻异常对象等。
6. **被同步锁持有的对象**.
7. **JMXBean、JVM TI回调、本地代码缓存等反映JVM内部情况的引用**.

#### 特殊情况

- **临时性加入**: 根据垃圾收集器及回收内存区域的不同，可能有其他对象临时加入GC Roots集合，确保分代收集和局部回收的准确性。[[3.4 HotSpot 虚拟机实现细节#^dfffab]]
- **优化处理**: 最新垃圾收集器（如G1、Shenandoah、ZGC等）通过优化减少GC Roots对象数量，避免过度膨胀。-----*分代收集& 局部回收*

